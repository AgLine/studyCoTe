https://school.programmers.co.kr/learn/courses/30/lessons/42584
---
스택을 사용하여 푸는 문제였지만 방법이 떠오르질않아 우선 할수있는방법으로 풀어보고자했음

O(N^2)의 시간복잡도 최악의 경우 100000*100000 연산을 할 수도있음하지만 가격이 떨어질경우 break를 통해 끝까지 연산을 하지않음

우선 여기에 기대를 걸어보고 문제를 풀었음

```
class Solution {
    public int[] solution(int[] prices) {
        int[] answer = new int [prices.length];
        int tmp = 1;//가격이 떨어져도 1의 값을 갖기때문에 1로 설정함
        
        for(int i = 0; i < prices.length; i++){
            for(int j = i+1; j < prices.length-1; j++){
                if(prices[i] <= prices[j]){//값이 같은경우도 떨어진걸로 보지않기 때문에 같거나 큰경우일때 tmp값이 증가하도록 설정
                    tmp++;
                }else{//값이 떨어졌을경우
                    break;
                }
            }
            answer[i] = tmp;
            tmp = 1;
        }
        answer[prices.length-1] = 0;//항상 마지막값은 0 이므로 
        return answer;
    }
}
```
<img width="1115" height="671" alt="image" src="https://github.com/user-attachments/assets/feedf64d-70bd-4c58-9230-089ea9833577" />

문제는 풀었긴한데 스택으로 푸는방법도 이해해보려함

---

https://claude.ai/share/0b81b357-ded5-4f3c-ab49-2d0617f34530

```
import java.util.Stack;
class Solution {
    public static int[] solution(int[] prices) {
        int n = prices.length;
        int[] answer = new int[n]; // ❶ 가격이 떨어지지 않은 기간을 저장할 배열
        // 스택(stack)을 사용해 이전 가격과 현재 가격 비교
        Stack<Integer> stack = new Stack<>(); // ❷ 스택 생성
        stack.push(0);
        for (int i = 1; i < n; i++) {
            while (!stack.isEmpty() && prices[i] < prices[stack.peek()]) {
                // ❸ 가격이 떨어졌으므로 이전 가격의 기간 계산
                int j = stack.pop();
                answer[j] = i - j;
            }
            stack.push(i);
        }
        // ❹ 스택에 남아 있는 가격들은 가격이 떨어지지 않은 경우
        while (!stack.isEmpty()) {
            int j = stack.pop();
            answer[j] = n - 1 - j;
        }
        return answer;
    }
}
```
